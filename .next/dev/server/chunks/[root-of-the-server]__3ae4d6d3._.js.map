{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/lib/db.ts"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst MONGODB_URI =\n  process.env.MONGODB_URI || \"mongodb://localhost:27017/petconnect\";\n\nif (!MONGODB_URI) {\n  throw new Error(\n    \"Please define the MONGODB_URI environment variable inside .env.local\"\n  );\n}\n\nlet cached = (global as any).mongoose;\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function connectDB() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\n      console.log(\"Connexion à la base de données réussie\");\n      return mongoose;\n    });\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\nexport default connectDB;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cACJ,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE7B;;AAMA,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IACA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QACA,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAa,MAAM,IAAI,CAAC,CAAC;YACzD,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT;IACF;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/models/User.ts"],"sourcesContent":["import mongoose, { Document, Schema } from \"mongoose\";\nimport bcrypt from \"bcryptjs\";\nimport connectDB from \"@/lib/db\";\n\nexport interface IUser extends Document {\n  _id: mongoose.Types.ObjectId;\n  firstName: string;\n  lastName: string;\n  email: string;\n  password: string;\n  phone?: string;\n  address?: string;\n  avatar?: string;\n  role: \"user\" | \"admin\" | \"vet\";\n  isVerified: boolean;\n  emailVerificationToken?: string;\n  emailVerificationExpires?: Date;\n  otp?: string;\n  otpExpires?: Date;\n  resetPasswordToken?: string;\n  resetPasswordExpires?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  googleId?: string;\n  comparePassword(candidatePassword: string): Promise<boolean>;\n}\n\nconst UserSchema = new Schema<IUser>(\n  {\n    firstName: { type: String, required: true, trim: true, maxlength: 50 },\n    lastName: { type: String, required: true, trim: true, maxlength: 50 },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      match: [\n        /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/,\n        \"Email invalide\",\n      ],\n    },\n    password: { type: String, required: true, minlength: 6, select: false },\n    phone: { type: String, maxlength: 20 },\n    address: { type: String, maxlength: 200 },\n    avatar: { type: String },\n    role: { type: String, enum: [\"user\", \"admin\", \"vet\"], default: \"user\" },\n    isVerified: { type: Boolean, default: false },\n    emailVerificationToken: { type: String, select: false },\n    emailVerificationExpires: { type: Date, select: false },\n    otp: { type: String, select: false },\n    otpExpires: { type: Date, select: false },\n    resetPasswordToken: { type: String, select: false },\n    resetPasswordExpires: { type: Date, select: false },\n    googleId: {\n      type: String,\n      required: false,\n      unique: true,\n      sparse: true,\n    },\n  },\n  { timestamps: true }\n);\n\n// Hash password before saving\nUserSchema.pre(\"save\", async function (next) {\n  if (!this.isModified(\"password\")) return next();\n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\n// Compare passwords\nUserSchema.methods.comparePassword = async function (\n  candidatePassword: string\n): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nconst User: mongoose.Model<IUser> =\n  mongoose.models.User || mongoose.model<IUser>(\"User\", UserSchema);\n\nexport default User;\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AA0BA,MAAM,aAAa,IAAI,mHAAM,CAC3B;IACE,WAAW;QAAE,MAAM;QAAQ,UAAU;QAAM,MAAM;QAAM,WAAW;IAAG;IACrE,UAAU;QAAE,MAAM;QAAQ,UAAU;QAAM,MAAM;QAAM,WAAW;IAAG;IACpE,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,OAAO;YACL;YACA;SACD;IACH;IACA,UAAU;QAAE,MAAM;QAAQ,UAAU;QAAM,WAAW;QAAG,QAAQ;IAAM;IACtE,OAAO;QAAE,MAAM;QAAQ,WAAW;IAAG;IACrC,SAAS;QAAE,MAAM;QAAQ,WAAW;IAAI;IACxC,QAAQ;QAAE,MAAM;IAAO;IACvB,MAAM;QAAE,MAAM;QAAQ,MAAM;YAAC;YAAQ;YAAS;SAAM;QAAE,SAAS;IAAO;IACtE,YAAY;QAAE,MAAM;QAAS,SAAS;IAAM;IAC5C,wBAAwB;QAAE,MAAM;QAAQ,QAAQ;IAAM;IACtD,0BAA0B;QAAE,MAAM;QAAM,QAAQ;IAAM;IACtD,KAAK;QAAE,MAAM;QAAQ,QAAQ;IAAM;IACnC,YAAY;QAAE,MAAM;QAAM,QAAQ;IAAM;IACxC,oBAAoB;QAAE,MAAM;QAAQ,QAAQ;IAAM;IAClD,sBAAsB;QAAE,MAAM;QAAM,QAAQ;IAAM;IAClD,UAAU;QACR,MAAM;QACN,UAAU;QACV,QAAQ;QACR,QAAQ;IACV;AACF,GACA;IAAE,YAAY;AAAK;AAGrB,8BAA8B;AAC9B,WAAW,GAAG,CAAC,QAAQ,eAAgB,IAAI;IACzC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,OAAO;IACzC,MAAM,OAAO,MAAM,8IAAM,CAAC,OAAO,CAAC;IAClC,IAAI,CAAC,QAAQ,GAAG,MAAM,8IAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;IACjD;AACF;AAEA,oBAAoB;AACpB,WAAW,OAAO,CAAC,eAAe,GAAG,eACnC,iBAAyB;IAEzB,OAAO,8IAAM,CAAC,OAAO,CAAC,mBAAmB,IAAI,CAAC,QAAQ;AACxD;AAEA,MAAM,OACJ,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAEzC","debugId":null}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/app/api/auth/google/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport jwt from \"jsonwebtoken\";\nimport connectDB from \"@/lib/db\";\nimport User from \"@/models/User\";\n\nconst JWT_SECRET = process.env.JWT_SECRET || \"your-secret-key\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { credential } = body; // Token Google JWT\n\n    if (!credential) {\n      return NextResponse.json(\n        { error: \"Token Google manquant\" },\n        { status: 400 }\n      );\n    }\n\n    // Décoder le token Google (sans vérification pour simplifier)\n    const decodedToken = jwt.decode(credential) as any;\n\n    if (!decodedToken || !decodedToken.email) {\n      return NextResponse.json(\n        { error: \"Token Google invalide\" },\n        { status: 400 }\n      );\n    }\n\n    await connectDB();\n\n    const {\n      email,\n      given_name,\n      family_name,\n      picture,\n      sub: googleId,\n    } = decodedToken;\n\n    // Vérifier si l'utilisateur existe déjà\n    let user = await User.findOne({ email });\n\n    if (!user) {\n      // Créer un nouvel utilisateur\n      user = new User({\n        firstName: given_name || \"Utilisateur\",\n        lastName: family_name || \"Google\",\n        email,\n        avatar: picture,\n        googleId,\n        password: \"google-oauth-\" + Math.random().toString(36),\n        isEmailVerified: true,\n      });\n      await user.save();\n    } else {\n      // Mettre à jour l'avatar si nécessaire\n      if (picture && !user.avatar) {\n        user.avatar = picture;\n        await user.save();\n      }\n    }\n\n    // Générer un token JWT\n    const token = jwt.sign(\n      { userId: user._id, email: user.email, role: user.role },\n      JWT_SECRET,\n      { expiresIn: \"7d\" }\n    );\n\n    return NextResponse.json(\n      {\n        message: \"Connexion Google réussie\",\n        user: {\n          _id: user._id,\n          firstName: user.firstName,\n          lastName: user.lastName,\n          email: user.email,\n          avatar: user.avatar,\n          role: user.role,\n        },\n        token,\n      },\n      { status: 200 }\n    );\n  } catch (error: any) {\n    console.error(\"Erreur Google auth:\", error);\n    return NextResponse.json(\n      { error: error.message || \"Erreur serveur\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,UAAU,EAAE,GAAG,MAAM,mBAAmB;QAEhD,IAAI,CAAC,YAAY;YACf,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,8DAA8D;QAC9D,MAAM,eAAe,kJAAG,CAAC,MAAM,CAAC;QAEhC,IAAI,CAAC,gBAAgB,CAAC,aAAa,KAAK,EAAE;YACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,IAAA,sHAAS;QAEf,MAAM,EACJ,KAAK,EACL,UAAU,EACV,WAAW,EACX,OAAO,EACP,KAAK,QAAQ,EACd,GAAG;QAEJ,wCAAwC;QACxC,IAAI,OAAO,MAAM,2HAAI,CAAC,OAAO,CAAC;YAAE;QAAM;QAEtC,IAAI,CAAC,MAAM;YACT,8BAA8B;YAC9B,OAAO,IAAI,2HAAI,CAAC;gBACd,WAAW,cAAc;gBACzB,UAAU,eAAe;gBACzB;gBACA,QAAQ;gBACR;gBACA,UAAU,kBAAkB,KAAK,MAAM,GAAG,QAAQ,CAAC;gBACnD,iBAAiB;YACnB;YACA,MAAM,KAAK,IAAI;QACjB,OAAO;YACL,uCAAuC;YACvC,IAAI,WAAW,CAAC,KAAK,MAAM,EAAE;gBAC3B,KAAK,MAAM,GAAG;gBACd,MAAM,KAAK,IAAI;YACjB;QACF;QAEA,uBAAuB;QACvB,MAAM,QAAQ,kJAAG,CAAC,IAAI,CACpB;YAAE,QAAQ,KAAK,GAAG;YAAE,OAAO,KAAK,KAAK;YAAE,MAAM,KAAK,IAAI;QAAC,GACvD,YACA;YAAE,WAAW;QAAK;QAGpB,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;gBACJ,KAAK,KAAK,GAAG;gBACb,WAAW,KAAK,SAAS;gBACzB,UAAU,KAAK,QAAQ;gBACvB,OAAO,KAAK,KAAK;gBACjB,QAAQ,KAAK,MAAM;gBACnB,MAAM,KAAK,IAAI;YACjB;YACA;QACF,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAAiB,GAC3C;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}