{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/lib/db.ts"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst MONGODB_URI =\n  process.env.MONGODB_URI || \"mongodb://localhost:27017/petconnect\";\n\nif (!MONGODB_URI) {\n  throw new Error(\n    \"Please define the MONGODB_URI environment variable inside .env.local\"\n  );\n}\n\nlet cached = (global as any).mongoose;\n\nif (!cached) {\n  cached = (global as any).mongoose = { conn: null, promise: null };\n}\n\nasync function connectDB() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n  if (!cached.promise) {\n    const opts = {\n      bufferCommands: false,\n    };\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\n      console.log(\"Connexion à la base de données réussie\");\n      return mongoose;\n    });\n  }\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\nexport default connectDB;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cACJ,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE7B;;AAMA,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IACA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QACA,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAa,MAAM,IAAI,CAAC,CAAC;YACzD,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT;IACF;IACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IAClC,OAAO,OAAO,IAAI;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/models/User.ts"],"sourcesContent":["import mongoose, { Document, Schema } from \"mongoose\";\nimport bcrypt from \"bcryptjs\";\nimport connectDB from \"@/lib/db\";\n\nexport interface IUser extends Document {\n  _id: mongoose.Types.ObjectId;\n  firstName: string;\n  lastName: string;\n  email: string;\n  password: string;\n  phone?: string;\n  address?: string;\n  avatar?: string;\n  role: \"user\" | \"admin\" | \"vet\";\n  isVerified: boolean;\n  otp?: string;\n  otpExpires?: Date;\n  resetPasswordToken?: string;\n  resetPasswordExpires?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  comparePassword(candidatePassword: string): Promise<boolean>;\n}\n\nconst UserSchema = new Schema<IUser>(\n  {\n    firstName: { type: String, required: true, trim: true, maxlength: 50 },\n    lastName: { type: String, required: true, trim: true, maxlength: 50 },\n    email: {\n      type: String,\n      required: true,\n      unique: true,\n      lowercase: true,\n      match: [\n        /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/,\n        \"Email invalide\",\n      ],\n    },\n    password: { type: String, required: true, minlength: 6, select: false },\n    phone: { type: String, maxlength: 20 },\n    address: { type: String, maxlength: 200 },\n    avatar: { type: String },\n    role: { type: String, enum: [\"user\", \"admin\", \"vet\"], default: \"user\" },\n    isVerified: { type: Boolean, default: false },\n    otp: { type: String, select: false },\n    otpExpires: { type: Date, select: false },\n    resetPasswordToken: { type: String, select: false },\n    resetPasswordExpires: { type: Date, select: false },\n  },\n  { timestamps: true }\n);\n\n// Hash password before saving\nUserSchema.pre(\"save\", async function (next) {\n  if (!this.isModified(\"password\")) return next();\n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\n// Compare passwords\nUserSchema.methods.comparePassword = async function (\n  candidatePassword: string\n): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nconst User: mongoose.Model<IUser> =\n  mongoose.models.User || mongoose.model<IUser>(\"User\", UserSchema);\n\nexport default User;\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAuBA,MAAM,aAAa,IAAI,mHAAM,CAC3B;IACE,WAAW;QAAE,MAAM;QAAQ,UAAU;QAAM,MAAM;QAAM,WAAW;IAAG;IACrE,UAAU;QAAE,MAAM;QAAQ,UAAU;QAAM,MAAM;QAAM,WAAW;IAAG;IACpE,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,OAAO;YACL;YACA;SACD;IACH;IACA,UAAU;QAAE,MAAM;QAAQ,UAAU;QAAM,WAAW;QAAG,QAAQ;IAAM;IACtE,OAAO;QAAE,MAAM;QAAQ,WAAW;IAAG;IACrC,SAAS;QAAE,MAAM;QAAQ,WAAW;IAAI;IACxC,QAAQ;QAAE,MAAM;IAAO;IACvB,MAAM;QAAE,MAAM;QAAQ,MAAM;YAAC;YAAQ;YAAS;SAAM;QAAE,SAAS;IAAO;IACtE,YAAY;QAAE,MAAM;QAAS,SAAS;IAAM;IAC5C,KAAK;QAAE,MAAM;QAAQ,QAAQ;IAAM;IACnC,YAAY;QAAE,MAAM;QAAM,QAAQ;IAAM;IACxC,oBAAoB;QAAE,MAAM;QAAQ,QAAQ;IAAM;IAClD,sBAAsB;QAAE,MAAM;QAAM,QAAQ;IAAM;AACpD,GACA;IAAE,YAAY;AAAK;AAGrB,8BAA8B;AAC9B,WAAW,GAAG,CAAC,QAAQ,eAAgB,IAAI;IACzC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,OAAO;IACzC,MAAM,OAAO,MAAM,8IAAM,CAAC,OAAO,CAAC;IAClC,IAAI,CAAC,QAAQ,GAAG,MAAM,8IAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;IACjD;AACF;AAEA,oBAAoB;AACpB,WAAW,OAAO,CAAC,eAAe,GAAG,eACnC,iBAAyB;IAEzB,OAAO,8IAAM,CAAC,OAAO,CAAC,mBAAmB,IAAI,CAAC,QAAQ;AACxD;AAEA,MAAM,OACJ,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAEzC","debugId":null}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/lib/auth.ts"],"sourcesContent":["// Client-safe auth utilities (no JWT verification)\nimport { NextRequest } from \"next/server\";\n\n// Types pour les payloads JWT\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n  iat?: number;\n  exp?: number;\n}\n\nexport interface AuthenticatedUser {\n  id: string;\n  email: string;\n  role: string;\n}\n\n// Extraire le token du header Authorization\nexport function extractTokenFromHeader(request: NextRequest): string | null {\n  const authHeader = request.headers.get(\"authorization\");\n  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n    return null;\n  }\n  return authHeader.substring(7); // Remove \"Bearer \" prefix\n}\n\n// Extraire le token depuis les cookies\nexport function extractTokenFromCookies(request: NextRequest): string | null {\n  const token = request.cookies.get(\"token\")?.value;\n  return token || null;\n}\n\n// Extraire le token (header ou cookie)\nexport function extractToken(request: NextRequest): string | null {\n  // Priorité au header Authorization\n  const headerToken = extractTokenFromHeader(request);\n  if (headerToken) return headerToken;\n\n  // Fallback sur les cookies\n  return extractTokenFromCookies(request);\n}\n\n// Vérifier si un token est expiré (utilise decodeToken qui ne nécessite pas JWT_SECRET)\nexport function isTokenExpired(token: string): boolean {\n  const decoded = decodeToken(token);\n  if (!decoded || !decoded.exp) return true;\n  return decoded.exp * 1000 < Date.now();\n}\n\n// Décoder un token JWT (sans vérification) - Version client-safe\nexport function decodeToken(token: string): JWTPayload | null {\n  try {\n    // Décoder manuellement le JWT sans bibliothèque (base64)\n    const parts = token.split(\".\");\n    if (parts.length !== 3) return null;\n\n    const payload = parts[1];\n    const decoded = JSON.parse(\n      atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\"))\n    );\n    return decoded as JWTPayload;\n  } catch (error) {\n    return null;\n  }\n}\n\n// NOTE: Les fonctions suivantes ont été déplacées vers lib/auth-server.ts\n// car elles nécessitent jsonwebtoken qui ne fonctionne que côté serveur:\n// - generateToken\n// - verifyToken\n// - authenticateUser\n// - generateRefreshToken\n// - verifyRefreshToken\n"],"names":[],"mappings":"AAAA,mDAAmD;;;;;;;;;;;;;AAmB5C,SAAS,uBAAuB,OAAoB;IACzD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,cAAc,CAAC,WAAW,UAAU,CAAC,YAAY;QACpD,OAAO;IACT;IACA,OAAO,WAAW,SAAS,CAAC,IAAI,0BAA0B;AAC5D;AAGO,SAAS,wBAAwB,OAAoB;IAC1D,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;IAC5C,OAAO,SAAS;AAClB;AAGO,SAAS,aAAa,OAAoB;IAC/C,mCAAmC;IACnC,MAAM,cAAc,uBAAuB;IAC3C,IAAI,aAAa,OAAO;IAExB,2BAA2B;IAC3B,OAAO,wBAAwB;AACjC;AAGO,SAAS,eAAe,KAAa;IAC1C,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,EAAE,OAAO;IACrC,OAAO,QAAQ,GAAG,GAAG,OAAO,KAAK,GAAG;AACtC;AAGO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,yDAAyD;QACzD,MAAM,QAAQ,MAAM,KAAK,CAAC;QAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;QAE/B,MAAM,UAAU,KAAK,CAAC,EAAE;QACxB,MAAM,UAAU,KAAK,KAAK,CACxB,KAAK,QAAQ,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM;QAEhD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF,EAEA,0EAA0E;CAC1E,yEAAyE;CACzE,kBAAkB;CAClB,gBAAgB;CAChB,qBAAqB;CACrB,yBAAyB;CACzB,uBAAuB","debugId":null}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/lib/auth-server.ts"],"sourcesContent":["import jwt from \"jsonwebtoken\";\nimport { NextRequest } from \"next/server\";\nimport {\n  JWTPayload,\n  AuthenticatedUser,\n  extractToken,\n  isTokenExpired,\n} from \"./auth\";\n\n// Fonctions pour obtenir JWT_SECRET et JWT_EXPIRES_IN\nfunction getJWTSecret(): string {\n  return (\n    process.env.JWT_SECRET ||\n    \"dev_fallback_secret_key_minimum_32_characters_for_security\"\n  );\n}\n\nfunction getJWTExpiresIn(): string {\n  return process.env.JWT_EXPIRES_IN || \"7d\";\n}\n\n// Générer un token JWT\nexport function generateToken(\n  payload: Omit<JWTPayload, \"iat\" | \"exp\">\n): string {\n  return jwt.sign(payload, getJWTSecret(), {\n    expiresIn: getJWTExpiresIn(),\n    issuer: \"PetCareVerse\",\n    audience: \"PetCareVerse-Users\",\n  } as jwt.SignOptions);\n}\n\n// Vérifier et décoder un token JWT\nexport function verifyToken(token: string): JWTPayload {\n  try {\n    const decoded = jwt.verify(token, getJWTSecret(), {\n      issuer: \"PetCareVerse\",\n      audience: \"PetCareVerse-Users\",\n    } as jwt.VerifyOptions) as JWTPayload;\n    return decoded;\n  } catch (error) {\n    throw new Error(\"Token invalide ou expiré\");\n  }\n}\n\n// Middleware helper pour vérifier l'authentification\nexport function authenticateUser(request: NextRequest): AuthenticatedUser {\n  // Essayer d'extraire le token depuis header ou cookies\n  const token = extractToken(request);\n  if (!token) {\n    throw new Error(\"Token d'authentification requis\");\n  }\n\n  if (isTokenExpired(token)) {\n    throw new Error(\"Token expiré\");\n  }\n\n  const decoded = verifyToken(token);\n  return {\n    id: decoded.userId,\n    email: decoded.email,\n    role: decoded.role,\n  };\n}\n\n// Générer un refresh token\nexport function generateRefreshToken(\n  payload: Omit<JWTPayload, \"iat\" | \"exp\">\n): string {\n  return jwt.sign(payload, getJWTSecret() + \"_REFRESH\", {\n    expiresIn: \"30d\",\n    issuer: \"PetCareVerse\",\n    audience: \"PetCareVerse-Refresh\",\n  } as jwt.SignOptions);\n}\n\n// Vérifier un refresh token\nexport function verifyRefreshToken(token: string): JWTPayload {\n  try {\n    const decoded = jwt.verify(token, getJWTSecret() + \"_REFRESH\", {\n      issuer: \"PetCareVerse\",\n      audience: \"PetCareVerse-Refresh\",\n    } as jwt.VerifyOptions) as JWTPayload;\n    return decoded;\n  } catch (error) {\n    throw new Error(\"Refresh token invalide ou expiré\");\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAEA;;;AAOA,sDAAsD;AACtD,SAAS;IACP,OACE,QAAQ,GAAG,CAAC,UAAU,IACtB;AAEJ;AAEA,SAAS;IACP,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI;AACvC;AAGO,SAAS,cACd,OAAwC;IAExC,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,gBAAgB;QACvC,WAAW;QACX,QAAQ;QACR,UAAU;IACZ;AACF;AAGO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,gBAAgB;YAChD,QAAQ;YACR,UAAU;QACZ;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF;AAGO,SAAS,iBAAiB,OAAoB;IACnD,uDAAuD;IACvD,MAAM,QAAQ,IAAA,6HAAY,EAAC;IAC3B,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,IAAA,+HAAc,EAAC,QAAQ;QACzB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,UAAU,YAAY;IAC5B,OAAO;QACL,IAAI,QAAQ,MAAM;QAClB,OAAO,QAAQ,KAAK;QACpB,MAAM,QAAQ,IAAI;IACpB;AACF;AAGO,SAAS,qBACd,OAAwC;IAExC,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,iBAAiB,YAAY;QACpD,WAAW;QACX,QAAQ;QACR,UAAU;IACZ;AACF;AAGO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,iBAAiB,YAAY;YAC7D,QAAQ;YACR,UAAU;QACZ;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF","debugId":null}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/services/userService.ts"],"sourcesContent":["import connectDB from \"../lib/db\";\nimport User, { IUser } from \"../models/User\";\nimport { generateToken, generateRefreshToken } from \"../lib/auth-server\";\nimport crypto from \"crypto\";\n\nexport class UserService {\n  // 1. Register (Inscription)\n  static async register(userData: {\n    firstName: string;\n    lastName: string;\n    email: string;\n    password: string;\n    phone?: string;\n    address?: string;\n  }): Promise<IUser> {\n    await connectDB();\n\n    // Vérifier que l'email n'existe pas déjà\n    const existingUser = await User.findOne({\n      email: userData.email.toLowerCase(),\n    });\n    if (existingUser) {\n      throw new Error(\"Cet email est déjà utilisé\");\n    }\n\n    // Validation supplémentaire\n    if (userData.password.length < 6) {\n      throw new Error(\"Le mot de passe doit contenir au moins 6 caractères\");\n    }\n\n    const user = new User({\n      ...userData,\n      email: userData.email.toLowerCase(),\n    });\n\n    await user.save();\n    return user;\n  }\n\n  // 2. Login (Connexion) - Version optimisée\n  static async login(\n    email: string,\n    password: string\n  ): Promise<{ user: IUser; token: string; refreshToken: string }> {\n    await connectDB();\n\n    const user = await User.findOne({ email: email.toLowerCase() }).select(\n      \"+password\"\n    );\n    if (!user) {\n      throw new Error(\"Email ou mot de passe incorrect\");\n    }\n\n    const isPasswordValid = await user.comparePassword(password);\n    if (!isPasswordValid) {\n      throw new Error(\"Email ou mot de passe incorrect\");\n    }\n\n    // Générer les tokens avec les utilitaires sécurisés\n    const token = generateToken({\n      userId: user._id.toString(),\n      email: user.email,\n      role: user.role,\n    });\n\n    const refreshToken = generateRefreshToken({\n      userId: user._id.toString(),\n      email: user.email,\n      role: user.role,\n    });\n\n    return { user, token, refreshToken };\n  }\n\n  // 3. Update Profile (Mettre à jour le profil)\n  static async updateProfile(\n    userId: string,\n    updateData: Partial<{\n      firstName: string;\n      lastName: string;\n      phone: string;\n      address: string;\n      avatar: string;\n    }>\n  ): Promise<IUser | null> {\n    await connectDB();\n    return User.findByIdAndUpdate(userId, updateData, {\n      new: true,\n      runValidators: true,\n    });\n  }\n\n  // 4. Forget Password (Demander réinitialisation de mot de passe)\n  static async forgetPassword(\n    email: string\n  ): Promise<{ resetToken: string; message: string }> {\n    await connectDB();\n\n    const user = await User.findOne({ email: email.toLowerCase() });\n    if (!user) {\n      throw new Error(\"Aucun utilisateur trouvé avec cet email\");\n    }\n\n    const resetToken = crypto.randomBytes(32).toString(\"hex\");\n    const hashedToken = crypto\n      .createHash(\"sha256\")\n      .update(resetToken)\n      .digest(\"hex\");\n    const expires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes\n\n    user.resetPasswordToken = hashedToken;\n    user.resetPasswordExpires = expires;\n    await user.save();\n\n    return {\n      resetToken,\n      message:\n        \"Un token de réinitialisation a été généré (à envoyer par email)\",\n    };\n  }\n\n  // 5. Generate OTP (Générer un OTP pour forgot password)\n  static async generateOTP(\n    email: string\n  ): Promise<{ otp: string; message: string }> {\n    await connectDB();\n\n    const user = await User.findOne({ email: email.toLowerCase() });\n    if (!user) {\n      throw new Error(\"Aucun utilisateur trouvé avec cet email\");\n    }\n\n    // Générer un OTP à 6 chiffres\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes\n\n    user.otp = otp;\n    user.otpExpires = otpExpires;\n    await user.save();\n\n    return {\n      otp,\n      message: \"Un code OTP a été généré\",\n    };\n  }\n\n  // 6. Verify OTP (Vérifier OTP reçu par email)\n  static async verifyOTP(\n    email: string,\n    otp: string\n  ): Promise<{ user: IUser; resetToken: string; message: string }> {\n    await connectDB();\n\n    const user = await User.findOne({\n      email: email.toLowerCase(),\n    }).select(\"+otp +otpExpires\");\n\n    if (!user) {\n      throw new Error(\"Utilisateur non trouvé\");\n    }\n\n    if (!user.otp || !user.otpExpires) {\n      throw new Error(\"Aucun OTP n'a été généré pour cet utilisateur\");\n    }\n\n    if (user.otp !== otp) {\n      throw new Error(\"OTP invalide\");\n    }\n\n    if (user.otpExpires < new Date()) {\n      throw new Error(\"OTP expiré\");\n    }\n\n    // Générer un token de réinitialisation\n    const resetToken = crypto.randomBytes(32).toString(\"hex\");\n    const hashedToken = crypto\n      .createHash(\"sha256\")\n      .update(resetToken)\n      .digest(\"hex\");\n    const expires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes\n\n    user.resetPasswordToken = hashedToken;\n    user.resetPasswordExpires = expires;\n    user.otp = undefined;\n    user.otpExpires = undefined;\n    await user.save();\n\n    return {\n      user,\n      resetToken,\n      message: \"OTP vérifié avec succès\",\n    };\n  }\n\n  // 7. Reset Password (Réinitialiser le mot de passe avec token)\n  static async resetPassword(\n    token: string,\n    newPassword: string\n  ): Promise<{ user: IUser; message: string }> {\n    await connectDB();\n\n    const hashedToken = crypto.createHash(\"sha256\").update(token).digest(\"hex\");\n\n    const user = await User.findOne({\n      resetPasswordToken: hashedToken,\n      resetPasswordExpires: { $gt: new Date() },\n    }).select(\"+password\");\n\n    if (!user) {\n      throw new Error(\"Token invalide ou expiré\");\n    }\n\n    // Validation du nouveau mot de passe\n    if (newPassword.length < 6) {\n      throw new Error(\"Le mot de passe doit contenir au moins 6 caractères\");\n    }\n\n    user.password = newPassword;\n    user.resetPasswordToken = undefined;\n    user.resetPasswordExpires = undefined;\n    await user.save();\n\n    return { user, message: \"Mot de passe réinitialisé avec succès\" };\n  }\n\n  // 8. Change Password (Changer le mot de passe actuel)\n  static async changePassword(\n    userId: string,\n    currentPassword: string,\n    newPassword: string\n  ): Promise<{ user: IUser; message: string }> {\n    await connectDB();\n\n    const user = await User.findById(userId).select(\"+password\");\n    if (!user) {\n      throw new Error(\"Utilisateur non trouvé\");\n    }\n\n    const isCurrentPasswordValid = await user.comparePassword(currentPassword);\n    if (!isCurrentPasswordValid) {\n      throw new Error(\"Mot de passe actuel incorrect\");\n    }\n\n    // Validation du nouveau mot de passe\n    if (newPassword.length < 6) {\n      throw new Error(\"Le mot de passe doit contenir au moins 6 caractères\");\n    }\n\n    user.password = newPassword;\n    await user.save();\n\n    return { user, message: \"Mot de passe changé avec succès\" };\n  }\n\n  // 9. Delete Profile (Supprimer le profil)\n  static async deleteProfile(userId: string): Promise<{ message: string }> {\n    await connectDB();\n\n    const user = await User.findByIdAndDelete(userId);\n    if (!user) {\n      throw new Error(\"Utilisateur non trouvé\");\n    }\n\n    return { message: \"Profil supprimé avec succès\" };\n  }\n\n  // 10. Get User by ID (Récupérer un utilisateur par ID)\n  static async getUserById(userId: string): Promise<IUser | null> {\n    await connectDB();\n    return User.findById(userId);\n  }\n\n  // 11. Get All Users (Admin only)\n  static async getAllUsers(): Promise<IUser[]> {\n    await connectDB();\n    return User.find({}).sort({ createdAt: -1 });\n  }\n\n  // 12. Get User by Email\n  static async getUserByEmail(email: string): Promise<IUser | null> {\n    await connectDB();\n    return User.findOne({ email: email.toLowerCase() });\n  }\n\n  // 13. Update User Role (Admin only)\n  static async updateUserRole(\n    userId: string,\n    role: \"user\" | \"admin\" | \"vet\"\n  ): Promise<IUser | null> {\n    await connectDB();\n    return User.findByIdAndUpdate(\n      userId,\n      { role },\n      { new: true, runValidators: true }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"sources":["file:///Users/med_yassine_khlaf/Documents/GitHub/PetConnect_PWA/app/api/auth/register/route.ts"],"sourcesContent":["import { UserService } from \"@/services/userService\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { firstName, lastName, email, password } = body;\n\n    // Validation basique\n    if (!firstName || !lastName || !email || !password) {\n      return NextResponse.json(\n        { error: \"Tous les champs sont requis\" },\n        { status: 400 }\n      );\n    }\n\n    // Appeler le service\n    const user = await UserService.register({\n      firstName,\n      lastName,\n      email,\n      password,\n    });\n\n    // Succès\n    return NextResponse.json(\n      { message: \"Inscription réussie\", user },\n      { status: 201 }\n    );\n  } catch (error: any) {\n    console.error(\"Erreur lors de l'inscription :\", error);\n    return NextResponse.json(\n      { error: error.message || \"Erreur serveur\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;QAEjD,qBAAqB;QACrB,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,SAAS,CAAC,UAAU;YAClD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,OAAO,MAAM,wIAAW,CAAC,QAAQ,CAAC;YACtC;YACA;YACA;YACA;QACF;QAEA,SAAS;QACT,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAuB;QAAK,GACvC;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAAiB,GAC3C;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}